using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;
using System.Collections;
using System.Threading;
using System.IO;

using Cognex.VisionPro;
using Cognex.VisionPro.QuickBuild;
using Cognex.VisionPro.QuickBuild.Implementation.Internal;
using Cognex.VisionPro.ToolGroup;
using Cognex.VisionPro.Implementation;
using Cognex.VisionPro.ToolGroup;
using Cognex.VisionPro.ResultsAnalysis;

namespace VisionControl
{
    public enum AccessLevel { Operator, Supervisor, Administrator }

    public partial class VisionControl : UserControl
    {
        #region Private data
        private const int MaximumPeriodMs = 500;
        private const int MinimumPeriodMs = 50;
        private System.Threading.Timer mMaximumGuiPeriodTimer;
        private System.Threading.Timer mMinimumGuiPeriodTimer;
        private bool mMinimumGuiUpdateNeeded = false;
        private bool mHaveUnpaintedResults = false;

        // Queue lengths, for the "all results" and "failing results" queues.
        // To disable the "failing results" queue, set its length to 1.  Queues must always be a least 1 element
        // in length, to hold the current result.
        private const int AllQueueLength = 16;
        private const int FailureQueueLength = 16;

        private PasswordFile mCurrentPasswordFile;
        private string mLoadedVppFilename;

        private OptionsFile mCurrentOptionsFile;

        private CogJobManager mJM = null;
        private bool mAttached = false;
        private int mSelectedJob = 0;
        private AccessLevel mCurrentAccessLevel;
        private CogJobResultHistoryCollection mHistoryCollection = new CogJobResultHistoryCollection();

        private enum RunState { Stopped, RunningContinuous, RunningOnce, RunningLive };
        private RunState mCurrentRunState = RunState.Stopped;
        private JobData[] mJobData = null;
        private bool mInitError = false;
        //private bool mStarted = false;
        private bool mIsClosing = false;

        // resource support for localization
        private Hashtable mResultTextHash;
        #endregion

        #region Public interface
        /// <summary>
        /// Read-only property to retrieve the CogJobManager.
        /// </summary>
        public CogJobManager JobManager
        {
            get { return mJM; }
        }

        /// <summary>
        /// Read-only property to retrieve the application name.
        /// </summary>
        public string ApplicationName
        {
            get { return mApplicationName; }
        }

        /// <summary>
        /// Read-only property to retrieve the filename of the loaded .vpp file.
        /// </summary>
        public string LoadedVppFilename
        {
            get { return mLoadedVppFilename; }
        }

        /// <summary>
        /// Read-only property indicating if passwords are in use by the generated code or not.
        /// </summary>
        public bool UsingPasswords
        {
            get { return mUsePasswords; }
        }

        /// <summary>
        /// If passwords are in use, returns the current password file.
        /// </summary>
        public PasswordFile CurrentPasswordFile
        {
            get { return mCurrentPasswordFile; }
        }

        /// <summary>
        /// Read-only property indicating the time at which this code was generated by the wizard.
        /// </summary>
        public static DateTime GenerationDateTime
        {
            get { return mGenerationDateTime; }
        }

        /// <summary>
        /// Read-only property indicating the what version of the wizard was used to generate this code.
        /// </summary>
        public static string GeneratedByVersion
        {
            get { return mGeneratedByVersion; }
        }

        /// <summary>
        /// Event fired for every user result produced by a job in the QuickBuild application (.vpp
        /// file).  The event is fired by the job thread itself, so any subscribers must handle this
        /// event in a timely manner.
        /// </summary>
        public event VisionControlUserResultAvailableEventHandler VisionControlUserResultAvailable = null;

        /// <summary>
        /// Clears all results from the result history queues of all jobs.
        /// </summary>
        public void ClearHistoryQueues(object sender, EventArgs e)
        {
            if (this.InvokeRequired)
            {
                // Call this same function on the GUI thread.
                Invoke(new EventHandler(ClearHistoryQueues), new object[] { sender, e });
                return;
            }

            foreach (ICogJobResultHistory h in mHistoryCollection)
            {
                h.Clear();
            }
        }

        /// <summary>
        /// This method serves to close the VisionControl. 
        /// It unsubscribes from the events of the JobManager instance and calls Shutdwon on it.
        /// Therefore this method should be called only at closing the Vision Application.
        /// </summary>
        public void Close()
        {
            AttachToJobManager(false);
            mIsClosing = true;
            if (mJM != null)
            {
                mJM.Shutdown();
                mJM = null;
            }
        }
        #endregion

        #region Initialization
        /*
         * For the vpp filename, first check using the full path supplied when the application
         * was generated.  This is intended for use primarily on developer machines.  If this
         * filename does not exist, then look in the same directory as the executable for
         * the vpp file, using just the filename portion.  This is the expected deployment
         * configuration.
         * 
         * For other files (such as the about box text file and password text file), first
         * check in the same directory as the vpp file, using the full path supplied when the
         * application was generated.  Then look in the same directory as the executable.
         */

        private static string ResolveVppFilename()
        {
            string fname = mVppFilename;

            // check if the developer vpp file path exists
            if (!System.IO.File.Exists(fname))
            {
                // if not, then try the filename in the same directory as this executable
                string justFilename = System.IO.Path.GetFileName(fname);
                fname = Utility.GetThisExecutableDirectory() + justFilename;
            }

            return fname;
        }

        public VisionControl()
        {
            InitializeComponent();
        }

        private bool PerformRequiredInit()
        {
            // resolve the quickbuild filename
            string vppFileToLoad = ResolveVppFilename();
            if (!File.Exists(vppFileToLoad) && !File.Exists(mVppFilename))
            {
                // vpp file does not exist in either developer location or current dir
                label_controlErrorMessage.Text = ResourceUtility.FormatString("RtVppNotFound", vppFileToLoad, mVppFilename);
                return false;
            }

            // create, validate & setup the password file
            string passwordfname = Utility.ResolveAssociatedFilename(mVppFilename, "passwords.txt");
            mCurrentPasswordFile = new PasswordFile(passwordfname);
            if (mCurrentPasswordFile.PasswordFileFound && !mCurrentPasswordFile.PasswordFileValid)
            {
                string quoted = "\"" + mCurrentPasswordFile.PasswordFilename + "\"";
                label_controlErrorMessage.Text = ResourceUtility.FormatString("RtInvalidPasswordFile", quoted);
                return false;
            }
            mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Administrator, mDefaultAdministratorPassword);
            mCurrentPasswordFile.SetDefaultPassword(AccessLevel.Supervisor, mDefaultSupervisorPassword);

            // load the QuickBuild project file
            try
            {
                mJM = (CogJobManager)CogSerializer.LoadObjectFromFile(vppFileToLoad);
            }
            catch (Exception ex)
            {
                label_controlErrorMessage.Text = ResourceUtility.GetString("RtErrorLoadingVpp") + ex.Message;
                return false;
            }

            mLoadedVppFilename = vppFileToLoad;

            // check for an uninitialized acquisition configuration
            for (int i = 0; i < mJM.JobCount; ++i)
            {
                if (mJM.Job(i).AcqFifoState == CogJobAcqFifoStateConstants.Invalid)
                {
                    label_controlErrorMessage.Text = ResourceUtility.FormatString("RtUninitializedAcq", mLoadedVppFilename);
                    return false;
                }
            }

            return true;
        }

        private void StartApplication()
        {
            //if (mStarted)
            //  return;

            //mStarted = true;
            mInitError = !PerformRequiredInit();

            if (mInitError)
            {
                cogRecordsDisplay1.Hide();
                tabControl_JobTabs.Hide();
                splitter2.Hide();
                panel6.Hide();
                UpdateControlsEnabled();
                return;
            }

            // create options file, read
            mCurrentOptionsFile = new OptionsFile();
            mCurrentOptionsFile.Read();

            // set the job manager to always generate user result records, even if nothing
            // was added to the user queue within QuickBuild
            mJM.UserQueueResultCreation = CogUserQueueResultCreationConstants.Always;

            // Flush queues
            Utility.FlushAllQueues(mJM);

            // Set up stats
            for (int i = 0; i < mJM.JobCount; i++)
                mJM.Job(i).ThroughputAlgorithm = CogJobThroughputAlgorithmConstants.MovingAverage;
            ResetStatisticsForAllJobs();

            try
            {
                Wizard_FormLoad();
            }
            catch (System.ArgumentOutOfRangeException)
            {
                // do nothing - handles case where fewer jobs than expected are
                // present in job manager
            }

            try
            {
                // resolve the logo filename
                string logoFilename = Utility.ResolveAssociatedFilename(mVppFilename, "logo.bmp");
                pictureBox_Logo.Image = new System.Drawing.Bitmap(logoFilename);

                // size the logo area to the needed height, and center the bitmap in that area
                int width = pictureBox_Logo.Size.Width;
                pictureBox_Logo.SizeMode = PictureBoxSizeMode.AutoSize;
                int height = pictureBox_Logo.Size.Height;
                pictureBox_Logo.SizeMode = PictureBoxSizeMode.CenterImage;
                pictureBox_Logo.Size = new System.Drawing.Size(width, height + 4);
            }
            catch (System.ArgumentException)
            {
                // do nothing - handles case where logo bitmap is not supplied
            }

            AttachToJobManager(true);
            UpdateGUIForSelectedJobChange(-1);

            // select the first tab page to start
            if (tabControl_JobTabs.TabPages.Count > 0)
                tabControl_JobTabs.SelectedTab = tabControl_JobTabs.TabPages[0];

            SetResultBarCurrent();

            // size result history window to number of jobs (or 8 max)
            const int maxJobsToSizeTo = 8;
            int rowHeight = cogJobResultHistoryCollectionEdit1.SelectorControlHeight;
            int totalHeight = rowHeight * (mJM.JobCount > maxJobsToSizeTo ? maxJobsToSizeTo : mJM.JobCount) + 8;
            int newPanel1Height = totalHeight + panel1.Height - cogJobResultHistoryCollectionEdit1.Height;
            if (panel1.Height < newPanel1Height)
                panel1.Height = newPanel1Height;
            if (mJM.JobCount > maxJobsToSizeTo)
            {
                // scale height of each row to fit remaining jobs (up to 10)
                const int maxJobsToScaleTo = 10;
                int scaleToFit = mJM.JobCount > maxJobsToScaleTo ? maxJobsToScaleTo : mJM.JobCount;
                int controlSpace = cogJobResultHistoryCollectionEdit1.Height - 4;
                cogJobResultHistoryCollectionEdit1.SelectorControlHeight = controlSpace / scaleToFit;
            }

            // setup the gui update timers
            mMaximumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMaximumGuiPeriodTimer_Elapsed), null,
              MaximumPeriodMs, MaximumPeriodMs);
            mMinimumGuiUpdateNeeded = false;
            mHaveUnpaintedResults = false;
            mMinimumGuiPeriodTimer = new System.Threading.Timer(new System.Threading.TimerCallback(mMinimumGuiPeriodTimer_Elapsed), null,
              MinimumPeriodMs, MinimumPeriodMs);

            // call required IO function
            mJM.IOPostLoadSetup(true);

            // enable IO if selected by options file
            if (mCurrentOptionsFile.EnableIOAtStartup)
            {
                try
                {
                    mJM.IOEnable = true;
                }
                catch (Cognex.VisionPro.Exceptions.CogException)
                { }
            }

            // start heartbeats, if QuickBuild app is configured for them
            mJM.RequestHeartbeat();
        }

        private void VisionControl_Load(object sender, EventArgs e)
        {
            // perform initialization to update the control gui - remainder of initialization
            // takes place in StartApplication
            if (mUsePasswords)
                mCurrentAccessLevel = AccessLevel.Operator;
            else
            {
                mCurrentAccessLevel = AccessLevel.Administrator;
                this.label_Login.Visible = false;
                this.comboBox_Login.Visible = false;
            }

            this.btnRun.Text = ResourceUtility.GetString("RtRunOnceButton");
            this.btnRunCont.Text = ResourceUtility.GetString("RtRunContinuouslyButton");
            this.button_About.Text = ResourceUtility.GetString("RtAboutButton");
            this.button_Chose.Text = ResourceUtility.GetString("RtChoseButton");
            this.button_Configuration.Text = ResourceUtility.GetString("RtConfigurationButton");
            this.checkBox_LiveDisplay.Text = ResourceUtility.GetString("RtLiveImageButton");
            this.button_SaveSettings.Text = ResourceUtility.GetString("RtSaveSettingsButton");

            this.label_Login.Text = ResourceUtility.GetString("RtCurrentLogin");

            comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Operator, ResourceUtility.GetString("RtOperator")));
            comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Supervisor, ResourceUtility.GetString("RtSupervisor")));
            comboBox_Login.Items.Add(new AccessLevel_Localized(AccessLevel.Administrator, ResourceUtility.GetString("RtAdministrator")));
            comboBox_Login.SelectedIndex = 0;

            label_Online.Text = ResourceUtility.GetString("RtSystemOffline");

            tabPage_JobN_JobStatistics.Text = ResourceUtility.GetString("RtStatsPageTitle");
            groupBox_JobResults.Text = ResourceUtility.GetString("RtStatsJobResultsGroup");
            label_JobResults_TotalIterations.Text = ResourceUtility.GetString("RtStatsJobIterations");
            label_JobResults_Accept.Text = ResourceUtility.GetString("RtStatsJobAcceptCount");
            label_JobResults_Error.Text = ResourceUtility.GetString("RtStatsJobErrorCount");
            label_JobResults_Reject.Text = ResourceUtility.GetString("RtStatsJobRejectCount");
            label_JobResults_Warning.Text = ResourceUtility.GetString("RtStatsJobWarningCount");
            label_JobResults_Percent.Text = ResourceUtility.GetString("RtStatsPercent");
            groupBox_AcquisitionResults.Text = ResourceUtility.GetString("RtStatsAcquisitionResultsGroup");
            label_AcquisitionResults_TotalAcquisitions.Text = ResourceUtility.GetString("RtStatsAcquisitions");
            label_AcquisitionResults_Errors.Text = ResourceUtility.GetString("RtStatsAcqErrorCount");
            label_AcquisitionResults_Overruns.Text = ResourceUtility.GetString("RtStatsAcqOverrunCount");
            groupBox_JobThroughput.Text = ResourceUtility.GetString("RtStatsJobThroughputGroup");
            label_JobThroughput_TotalThroughput.Text = ResourceUtility.GetString("RtStatsJobThroughput");
            label_JobThroughput_Min.Text = ResourceUtility.GetString("RtStatsThroughputMin");
            label_JobThroughput_Max.Text = ResourceUtility.GetString("RtStatsThroughputMax");
            label_JobThroughput_persec.Text = ResourceUtility.GetString("RtStatsPerSecond");
            button_ResetStatistics.Text = ResourceUtility.GetString("RtStatsReset");
            button_ResetStatisticsForAllJobs.Text = ResourceUtility.GetString("RtStatsResetAll");

            this.mResultTextHash = new Hashtable();
            this.mResultTextHash.Add(CogToolResultConstants.Accept, ResourceUtility.GetString("RtAccept"));
            this.mResultTextHash.Add(CogToolResultConstants.Warning, ResourceUtility.GetString("RtWarning"));
            this.mResultTextHash.Add(CogToolResultConstants.Reject, ResourceUtility.GetString("RtReject"));
            this.mResultTextHash.Add(CogToolResultConstants.Error, ResourceUtility.GetString("RtError"));

            if (!DesignMode)
                StartApplication();
        }

        private void AttachToJobManager(bool attach)
        {
            // attach and detach our event handlers/etc
            if (attach)
            {
                if (mAttached)
                    return;

                try
                {
                    Wizard_AttachPropertyProviders();
                }
                catch (System.ArgumentOutOfRangeException)
                {
                    // do nothing - handles case where fewer jobs than expected are
                    // present in job manager
                }

                mAttached = true;

                // Create a collection of history items for each job.
                // Preserve the history of any jobs that we already have - create new items for any
                // new jobs.
                CogJobResultHistoryCollection jobs = new CogJobResultHistoryCollection();
                bool changed = false;
                for (int j = 0; j < mJM.JobCount; ++j)
                {
                    int i = mHistoryCollection.IndexOf(mJM.Job(j).Name);
                    if (i != -1)
                    {
                        if (i != jobs.Count) changed = true;
                        jobs.Add(mHistoryCollection[i]);
                    }
                    else
                    {
                        jobs.Add(new CogJobResultHistoryGated(mJM.Job(j).Name, AllQueueLength, FailureQueueLength));
                        changed = true;
                    }
                }
                if (jobs.Count != mHistoryCollection.Count)
                    changed = true;
                if (changed)
                {
                    mHistoryCollection = jobs;
                    cogJobResultHistoryCollectionEdit1.Subject = jobs;
                    mSelectedJob = 0;
                }

                foreach (CogJobResultHistoryGated hist in mHistoryCollection)
                {
                    hist.CurrentItemChanged += new EventHandler(cogJobResultHistory_CurrentItemChanged);
                    hist.InternalQueue.CurrentQueueChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                    hist.InternalQueue.CurrentItemChanged += new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                }
                mJM.Stopped += new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
                mJM.UserResultAvailable += new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
                mJM.Changed += new CogChangedEventHandler(mJM_ChangedHandler);

                for (int i = 0; i < mJM.JobCount; ++i)
                {
                    mJM.Job(i).Running += new CogJob.CogJobRunningEventHandler(Job_Running);
                    mJM.Job(i).ImageQueueOverflowed += new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
                }

                // pull off and handle any items currently in the UserQueue
                HandleUserResults();

                // update the state of controls to reflect any changes made in config mode
                UpdateControlsEnabled();
                UpdateOnlineStatus();
            }
            else
            {
                if (!mAttached)
                    return;

                Wizard_DetachPropertyProviders();
                mAttached = false;

                foreach (CogJobResultHistoryGated hist in mHistoryCollection)
                {
                    hist.CurrentItemChanged -= new EventHandler(cogJobResultHistory_CurrentItemChanged);
                    hist.InternalQueue.CurrentQueueChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                    hist.InternalQueue.CurrentItemChanged -= new EventHandler(cogJobResultHistory_RequestImmediateUpdate);
                }

                mJM.Stopped -= new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped);
                mJM.UserResultAvailable -= new CogJobManager.CogUserResultAvailableEventHandler(mJM_UserResultAvailable);
                mJM.Changed -= new CogChangedEventHandler(mJM_ChangedHandler);

                for (int i = 0; i < mJM.JobCount; ++i)
                {
                    mJM.Job(i).Running -= new CogJob.CogJobRunningEventHandler(Job_Running);
                    mJM.Job(i).ImageQueueOverflowed -= new CogJob.CogImageQueueOverflowedEventHandler(Job_ImageQueueOverflowed);
                }
            }
        }
        #endregion

        #region Runtime implementation
        private void btnRun_Click(object sender, System.EventArgs e)
        {
            if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
                return;

            // update control state here to prevent an error from a quick button doubleclick
            mCurrentRunState = RunState.RunningOnce;
            UpdateControlsEnabled();

            try
            {
                mJM.Run();

                // note that mJM_Stopped will be called when run is complete
            }
            catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
            {
                // do nothing in this case - we're already running
            }
            catch (Cognex.VisionPro.Exceptions.CogException ex)
            {
                mCurrentRunState = RunState.Stopped;
                UpdateControlsEnabled();
                MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                  mApplicationName);
            }
        }

        private void btnRunCont_Click(object sender, System.EventArgs e)
        {
            if (mCurrentRunState == RunState.RunningContinuous)
            {
                // Stop continuous
                mJM.Stop();

                // note that mJM_Stopped will be called when job manager has completed this stop
                // request
            }
            else
            {
                // update control state here to prevent an error from a quick button doubleclick
                mCurrentRunState = RunState.RunningContinuous;
                UpdateControlsEnabled();

                try
                {
                    mJM.RunContinuous();
                }
                catch (Cognex.VisionPro.Exceptions.CogNotStoppedException)
                {
                    // do nothing in this case - we're already running
                }
                catch (Cognex.VisionPro.Exceptions.CogException ex)
                {
                    mCurrentRunState = RunState.Stopped;
                    UpdateControlsEnabled();
                    MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                      mApplicationName);
                }
            }
        }

        private void UpdateControlsEnabled()
        {
            // Enable or disable controls based on our current run state
            bool running = mCurrentRunState != RunState.Stopped;
            bool runningLive = mCurrentRunState == RunState.RunningLive;
            bool runningContinuous = mCurrentRunState == RunState.RunningContinuous;
            bool currentJobCanLive = mJM != null && mJM.JobCount > mSelectedJob && mJM.Job(mSelectedJob).AcqFifo != null;

            bool canConfig = !running && mCurrentAccessLevel == AccessLevel.Administrator;
            bool canSaveSettings = !running && mCurrentAccessLevel >= AccessLevel.Supervisor;

            btnRun.Enabled = !mInitError && !running;
            button_Configuration.Enabled = !mInitError && canConfig;
            button_SaveSettings.Enabled = !mInitError && canSaveSettings;
            button_About.Enabled = !running;

            if (mInitError)
            {
                label_Login.Enabled = false;
                comboBox_Login.Enabled = false;
                label_Online.Enabled = false;
            }

            // live display button is enabled if the current job can run live and either
            //   we're not running and the live display button is "up" or
            //   we are running and the live display button is "down"
            checkBox_LiveDisplay.Enabled = !mInitError && currentJobCanLive &&
              ((mCurrentRunState == RunState.Stopped && checkBox_LiveDisplay.Checked == false) ||
               (mCurrentRunState == RunState.RunningLive && checkBox_LiveDisplay.Checked == true));

            btnRunCont.Enabled = !mInitError && (!running || runningContinuous);
            btnRunCont.Text = runningContinuous ? (ResourceUtility.GetString("RtStopButton")) :
              (ResourceUtility.GetString("RtRunContinuouslyButton"));

            button_ResetStatistics.Enabled = !mInitError && !runningLive;
            button_ResetStatisticsForAllJobs.Enabled = !mInitError && !runningLive;

            Wizard_EnableControls(running);

            // update the monitor window for live display
            int count = mJM == null ? 0 : mJM.JobCount;
            for (int j = 0; j < count; ++j)
            {
                if (j < cogJobResultHistoryCollectionEdit1.SelectorControls.Count)
                {
                    Control ctl = (Control)cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[j]];
                    if (runningLive)
                    {
                        bool waitingForStop = !checkBox_LiveDisplay.Enabled;
                        ctl.Enabled = !waitingForStop && (mJM.Job(j).AcqFifo != null) &&
                          (j == mSelectedJob || mJM.Job(j).State == CogJobStateConstants.Stopped);
                    }
                    else
                        ctl.Enabled = true;
                }
            }
        }

        private void UpdateOnlineStatus()
        {
            // update the online/offline status indication

            // check if update needed
            if (label_Online.Tag != null && (bool)label_Online.Tag == mJM.IOEnable)
                return;

            string resStr = mJM.IOEnable ? "RtSystemOnline" : "RtSystemOffline";
            string displayStr = ResourceUtility.GetString(resStr);
            label_Online.Text = displayStr;
            label_Online.Tag = mJM.IOEnable;
        }

        private void HandleUserResults()
        {
            // take the latest result and push it into a queue

            ICogRecord result = mJM.UserResult();
            if (result != null)
            {
                string jobName = (string)result.SubRecords["JobName"].Content;
                int jobIndex = Utility.GetJobIndexFromName(mJM, jobName);
                // note - ignore unknown job names
                if (jobIndex >= 0)
                {
                    // push the result into the appropriate history queue
                    mHistoryCollection[jobIndex].AddNewUserResult(result);

                    // pass the result on to any listeners
                    VisionControlUserResultAvailableEventHandler delegateCopy = VisionControlUserResultAvailable;
                    if (delegateCopy != null)
                    {
                        delegateCopy(this, new VisionControlUserResultAvailableEventArgs(jobIndex, result));
                    }

                    lock (mMinimumGuiPeriodTimer)
                    {
                        mHaveUnpaintedResults = true;
                    }
                }
            }
        }

        private void mJM_UserResultAvailable(object sender, CogJobManagerActionEventArgs e)
        {
            HandleUserResults();
            UpdateGuiIfNeeded();
        }

        private void mJM_ImageAvailable(object sender, CogJobActionEventArgs e)
        {
            // called when new images are available in live video mode only

            try
            {
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // Invoke currently has a bug, and it is fixed in .NET2.0
                    IAsyncResult async = BeginInvoke(new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable), new object[] { sender, e });
                    while (!async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;
                    EndInvoke(async);
                    return;
                }

                // display the image if it is from the currently selected job (otherwise ignore it)
                CogJob j = (CogJob)sender;
                int idx = Utility.GetJobIndexFromName(mJM, j.Name);
                if (idx == mSelectedJob)
                    cogRecordsDisplay1.Display.Image = j.Image();
            }
            catch { }
        }

        private void Job_Running(object sender, CogJobActionEventArgs e)
        {
            // handles:
            //   - gui updates for job run commands issued via IO

            try
            {
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // No need to wait for it here, so ignore the asyncresult return value and return immediately
                    BeginInvoke(new CogJob.CogJobRunningEventHandler(Job_Running), new object[] { sender, e });
                    return;
                }

                // if we are getting this event because the live button was pressed, then we don't have
                // any work to do
                bool isLive = mCurrentRunState == RunState.RunningLive;
                if (isLive)
                    return;

                RunState newrunstate = RunState.Stopped;

                switch (e.Action)
                {
                    case CogActionConstants.RunningContinuous:
                        newrunstate = RunState.RunningContinuous;
                        break;
                    case CogActionConstants.RunningSingle:
                        newrunstate = RunState.RunningOnce;
                        break;
                    default:
                        break;
                }

                // only perform gui changes if we haven't done them already
                if (mCurrentRunState != newrunstate)
                {
                    mCurrentRunState = newrunstate;
                    UpdateControlsEnabled();
                }
            }
            catch { }
        }

        private void mJM_Stopped(object sender, CogJobManagerActionEventArgs e)
        {
            // handles:
            //    - exit from continuous mode
            //    - completion of a single run ("run once")
            //    - exit from live mode

            try
            {
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // No need to wait for it here, so ignore the asyncresult return value and return immediately
                    BeginInvoke(new CogJobManager.CogJobManagerStoppedEventHandler(mJM_Stopped), new object[] { sender, e });
                    return;
                }

                bool stoppingLive = mCurrentRunState == RunState.RunningLive || checkBox_LiveDisplay.Checked;

                mCurrentRunState = RunState.Stopped;

                if (stoppingLive)
                {
                    RestoreJobStates();

                    // clear any statistics
                    ResetStatisticsForAllJobs();

                    // go back to displaying last result for selected job
                    cogRecordsDisplay1.Subject = null;
                    cogRecordsDisplay1.Display.Image = null;
                    UpdateGUIForSelectedJob(true);

                    // Need to make sure the checkbox back to unchecked, in case the stopped event is occurring due
                    // to IO, instead of a button click.
                    // Note that this may cause a "checked == false" event to occur.
                    checkBox_LiveDisplay.Checked = false;
                }

                UpdateGui(null, null);
                UpdateControlsEnabled();
                SetResultBarCurrent();
            }
            catch { }
        }

        private void mJM_JobStopped(object sender, CogJobActionEventArgs e)
        {
            if (e.Action == CogActionConstants.StoppedContinuous ||
               e.Action == CogActionConstants.RunningContinuous)
            {
                try
                {
                    if (this.InvokeRequired)
                    {
                        // Call this same function on the GUI thread.
                        // No need to wait for it here, so ignore the asyncresult return value and return immediately
                        BeginInvoke(new CogJob.CogJobStoppedEventHandler(mJM_JobStopped), new object[] { sender, e });
                        return;
                    }

                    UpdateControlsEnabled();
                }
                catch { }
            }
        }

        private void mJM_ChangedHandler(object sender, CogChangedEventArgs e)
        {
            if ((e.StateFlags & CogJobManager.SfIOEnable) != 0)
            {
                lock (mMinimumGuiPeriodTimer)
                {
                    mMinimumGuiUpdateNeeded = true;
                }
            }
        }

        private int FindResultHistoryIndex(object sender)
        {
            int jobIndex;
            for (jobIndex = 0; jobIndex < mHistoryCollection.Count; ++jobIndex)
                if (Object.ReferenceEquals(sender, mHistoryCollection[jobIndex]))
                    break;
            if (jobIndex == mHistoryCollection.Count)
                return -1;  // unknown job
            return jobIndex;
        }

        private CogJobResultHistoryEdit FindResultHistoryEdit(CogJob job)
        {
            int jobIndex = Utility.GetJobIndexFromName(mJM, job.Name);
            Cognex.VisionPro.Implementation.Internal.CogToggleButton item =
                (Cognex.VisionPro.Implementation.Internal.CogToggleButton)
                cogJobResultHistoryCollectionEdit1.SelectorControls[mHistoryCollection[jobIndex]];
            return item.Content as CogJobResultHistoryEdit;
        }

        private void Job_ImageQueueOverflowed(object sender, CogJobActionEventArgs e)
        {
            // sets gui "error occurred" icon for given job to "on"
            try
            {
                CogJobResultHistoryEdit edit = FindResultHistoryEdit((CogJob)sender);
                if (!edit.ErrorIconVisible)
                {
                    edit.ErrorIconVisible = true;
                    edit.ErrorIconClicked += new EventHandler(cogJobResultHistory_ErrorIconClicked);
                }
            }
            catch { }
        }

        private void cogJobResultHistory_ErrorIconClicked(object sender, System.EventArgs e)
        {
            ICogJobResultHistory history = ((CogJobResultHistoryEdit)sender).Subject;

            // get job name
            int jobIndex = FindResultHistoryIndex(history);
            if (jobIndex < 0)
                return;

            string jobname = mJM.Job(jobIndex).Name;

            // for now, show a brief error message.  in the future, we may bring up a more
            // flexible error log here
            MessageBox.Show(ResourceUtility.FormatString("RtImageQueueOverrun", jobname),
              mApplicationName, MessageBoxButtons.OK);

            // since the message has been viewed, now clear the sender's error icon display
            CogJobResultHistoryEdit edit = FindResultHistoryEdit(mJM.Job(jobIndex));
            edit.ErrorIconVisible = false;
            edit.ErrorIconClicked -= new EventHandler(cogJobResultHistory_ErrorIconClicked);
        }

        private void UpdateGUIForSelectedJobChange(int oldJob)
        {
            // update the gui when the user changes the currently selected job

            TabPage oldSelected = this.tabControl_JobTabs.SelectedTab;
            ArrayList newPagesList = new ArrayList();

            // add in the tabs for the selected job
            // set the selected job text
            Wizard_AddJobTabs(newPagesList);

            // remove all the tabs
            tabControl_JobTabs.Controls.Clear();

            // add in the tabs available at current access level
            //添加Job Tab页面
            foreach (TabPage page in newPagesList)
            {
                if (page.Tag == null || Utility.AccessAllowed(page.Tag.ToString(), mCurrentAccessLevel))
                    tabControl_JobTabs.Controls.Add(page);
            }

            //作业执行统计页面
            tabControl_JobTabs.Controls.Add(tabPage_JobN_JobStatistics);

            if (tabControl_JobTabs.TabPages.Contains(oldSelected))
                this.tabControl_JobTabs.SelectedTab = oldSelected;
            else if (tabControl_JobTabs.TabPages.Count > 0)
                this.tabControl_JobTabs.SelectedTab = tabControl_JobTabs.TabPages[0];

            // handle job change while live video enabled
            if (this.mCurrentRunState == RunState.RunningLive && oldJob >= 0)
            {
                // start new job
                this.StartLiveDisplay(mSelectedJob);
                // stop old job
                this.StopLiveDisplay(oldJob);
            }

            UpdateControlsEnabled();
            UpdateStatisticsForJob(mSelectedJob);
        }

        private static string[] _updateDisplayStrings = new string[] { "ShowLastRunRecordForUserQueue", "LastRun" };

        private void UpdateGUIForSelectedJob(bool newSelectedJob)
        {
            // update the image and result bar to reflect the currently selected item of the
            // the currently selected job

            ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;
            if (result == null)
                return;

            if (mCurrentRunState != RunState.RunningLive)
            {
                if (mCurrentOptionsFile.EnableImageDisplay)
                {
                    // take the LastRunRecord (for the currently selected job) and put it in the record display.
                    // put an empty record in if no LastRunRecord is available
                    if (!Utility.AddRecordToDisplay(cogRecordsDisplay1, result, _updateDisplayStrings, newSelectedJob))
                        cogRecordsDisplay1.Subject = null;
                }
                else
                    cogRecordsDisplay1.Subject = null;
            }

            SetResultBarCurrent();
        }

        private void UpdateGUIForJob(int idx)
        {
            // update the tab pages to reflect the currently selected item of the the currently
            // selected job

            ICogRecord result = mHistoryCollection[idx].CurrentItem;

            // fill in the tab results
            Wizard_UpdateJobResults(idx, result);
        }

        private void SetResultBarCurrent()
        {
            string text;
            CogRunStatus rs = null;

            text = mJM.Job(mSelectedJob).Name;

            if (mCurrentRunState == RunState.RunningLive)
                text += ": " + ResourceUtility.GetString("RtLiveImageButton");
            else
            {
                ICogRecord result = mHistoryCollection[mSelectedJob].CurrentItem;

                if (result != null)
                {
                    rs = (CogRunStatus)result.SubRecords["RunStatus"].Content;

                    text += ": " + (string)this.mResultTextHash[rs.Result];
                }
            }

            label_ResultBar.Text = text;
            label_ResultBar.BackColor = GetColorFromRunStatus(rs);
        }

        private System.Drawing.Color GetColorFromRunStatus(CogRunStatus status)
        {
            System.Drawing.Color color;
            if (status != null)
            {
                switch (status.Result)
                {
                    case CogToolResultConstants.Accept:
                        color = System.Drawing.Color.FromArgb(0, 200, 0);
                        break;
                    case CogToolResultConstants.Warning:
                        color = System.Drawing.Color.Yellow;
                        break;
                    case CogToolResultConstants.Reject:
                    case CogToolResultConstants.Error:
                    default:
                        color = System.Drawing.Color.Red;
                        break;
                }
            }
            else
                color = System.Drawing.Color.FromKnownColor(KnownColor.ControlDark);

            return color;
        }

        private void cogJobResultHistoryCollectionEdit1_SelectedJobIndexChanged(object sender, System.EventArgs e)
        {
            if (cogJobResultHistoryCollectionEdit1.Subject != null && cogJobResultHistoryCollectionEdit1.SelectedIndex >= 0 &&
              cogJobResultHistoryCollectionEdit1.SelectedIndex != mSelectedJob)
            {
                int oldJob = mSelectedJob;
                mSelectedJob = cogJobResultHistoryCollectionEdit1.SelectedIndex;

                UpdateGUIForSelectedJobChange(oldJob);
                UpdateGUIForSelectedJob(true);
            }
        }

        private void cogJobResultHistory_CurrentItemChanged(object sender, System.EventArgs e)
        {
            bool newResultForSelectedJob = false;

            int jobIndex = FindResultHistoryIndex(sender);
            if (jobIndex < 0)
                return;

            if (jobIndex == mSelectedJob)
                newResultForSelectedJob = true;

            UpdateGUIForJob(jobIndex);

            // if there is a new result for the selected job, update the gui now
            if (newResultForSelectedJob)
                UpdateGUIForSelectedJob(false);
        }
        #endregion

        #region Live Display
        private void StartLiveDisplay(int jobNumber)
        {
            CogJob j = mJM.Job(jobNumber);
            if (j.State == CogJobStateConstants.Stopped)
                j.RunContinuous();
        }

        private void StopLiveDisplay(int jobNumber)
        {
            CogJob j = mJM.Job(jobNumber);
            if (j.State == CogJobStateConstants.RunningContinuous)
                j.Stop();
        }

        private void checkBox_LiveDisplay_CheckedChanged(object sender, System.EventArgs e)
        {
            if (checkBox_LiveDisplay.Checked == true)
            {
                // clear stats
                ResetStatisticsForAllJobs();
                for (int i = 0; i < mJM.JobCount; i++)
                    UpdateStatisticsForJob(i);

                // enable live
                mCurrentRunState = RunState.RunningLive;
                SetResultBarCurrent();
                cogRecordsDisplay1.Subject = null;

                // save old modes & setup jobs for live
                SetupForLive();

                try
                {
                    StartLiveDisplay(mSelectedJob);
                }
                catch (Cognex.VisionPro.Exceptions.CogException ex)
                {
                    RestoreJobStates();
                    mCurrentRunState = RunState.Stopped;
                    SetResultBarCurrent();
                    MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                      mApplicationName);

                    // need to set the checkbox back to unchecked - note that this causes a recurse call
                    // to occur, so the "checked == false" handling below needs to be able to handle this
                    checkBox_LiveDisplay.Checked = false;
                }
            }
            else
            {
                // stop live
                StopLiveDisplay(mSelectedJob);
            }

            UpdateControlsEnabled();
        }

        private void SetupForLive()
        {
            mJobData = new JobData[mJM.JobCount];
            for (int i = 0; i < mJobData.Length; ++i)
            {
                mJobData[i] = new JobData();

                CogJob j = mJM.Job(i);
                mJobData[i].lastRunMode = j.RunMode;
                mJobData[i].lastStartMode = j.StartMode;

                j.StartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
                j.RunMode = CogJobRunModeConstants.AcquisitionOnly;
                j.ImageAvailable += new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
                j.Stopped += new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
            }
        }

        private void RestoreJobStates()
        {
            // restore all jobs start & run modes
            for (int idx = 0; idx < mJM.JobCount; ++idx)
            {
                CogJob j = mJM.Job(idx);
                j.StartMode = mJobData[idx].lastStartMode;
                j.RunMode = mJobData[idx].lastRunMode;
                j.ImageAvailable -= new CogJob.CogImageAvailableEventHandler(mJM_ImageAvailable);
                j.Stopped -= new CogJob.CogJobStoppedEventHandler(mJM_JobStopped);
            }

            // done with jobdata
            mJobData = null;
        }
        #endregion

        #region Login
        private void comboBox_Login_SelectionChangeCommitted(object sender, System.EventArgs e)
        {
            AccessLevel newAccessLevel = ((AccessLevel_Localized)(comboBox_Login.SelectedItem)).val;

            // prompt for a password - only update accessLevel if promt is successful
            if (PromptForAccessLevelChange(newAccessLevel))
                mCurrentAccessLevel = newAccessLevel;

            // update gui to reflect current accessLevel
            foreach (AccessLevel_Localized al in comboBox_Login.Items)
                if (al.val == mCurrentAccessLevel)
                    comboBox_Login.SelectedItem = al;
            this.UpdateGUIForSelectedJobChange(-1);
        }

        private bool PromptForAccessLevelChange(AccessLevel newAccessLevel)
        {
            // not using passwords, or going "down" in access level - always allowed
            if (!mUsePasswords || newAccessLevel <= mCurrentAccessLevel)
                return true;

            string expected = mCurrentPasswordFile.GetPasswordForAccessLevel(newAccessLevel);
            if (expected != "")
            {
                // get password from user
                FormPasswordPrompt prompt = new FormPasswordPrompt();
                prompt.Text = ResourceUtility.FormatString("RtEnterPassword", newAccessLevel.ToString());
                DialogResult result = prompt.ShowDialog(this);
                if (result != DialogResult.OK)
                    return false;
                if (prompt.Password != expected)
                {
                    MessageBox.Show(ResourceUtility.GetString("RtInvalidPassword2"), ResourceUtility.GetString("RtInvalidPassword"));
                    return false;
                }
            }

            return true;
        }
        #endregion

        #region Other buttons (config, save settings, about)
        private void button_Configuration_Click(object sender, System.EventArgs e)
        {
            FormConfig frmConfigSelect = new FormConfig(mQuickBuildAccess, mUsePasswords);
            frmConfigSelect.ShowDialog(this);

            switch (frmConfigSelect.Result)
            {
                case FormConfigResult.None:
                    break;

                case FormConfigResult.QuickBuild:
                    // detach from job manager before displaying edit control
                    AttachToJobManager(false);

                    // put up a new dialog containing QB editor
                    FormQB frm = new FormQB(mJM);
                    frm.ShowDialog(this);
                    frm.Dispose();

                    // prompt for save of vpp file
                    string vpp = mLoadedVppFilename;
                    string quotedvpp = "\"" + vpp + "\"";
                    string saveButtonName = ResourceUtility.GetString("RtSaveSettingsButton");
                    string quotedSaveButtonName = "\"" + saveButtonName + "\"";
                    string promptStr = ResourceUtility.FormatString("RtSaveSettingsTextAfterConfig", quotedvpp, quotedSaveButtonName);
                    PromptToSaveSettings(promptStr);

                    // re-attach
                    AttachToJobManager(true);
                    break;

                case FormConfigResult.SetPasswords:
                    FormSetPasswords frmPasswords = new FormSetPasswords(mCurrentPasswordFile);
                    frmPasswords.ShowDialog(this);
                    break;

                case FormConfigResult.AppOptions:
                    FormAppOptions frmOptions = new FormAppOptions(this);
                    frmOptions.EnableDisplay = mCurrentOptionsFile.EnableImageDisplay;
                    frmOptions.EnableIOAtStartup = mCurrentOptionsFile.EnableIOAtStartup;
                    frmOptions.EnableIO = mJM.IOEnable;
                    DialogResult result = frmOptions.ShowDialog(this);
                    if (result == DialogResult.OK)
                    {
                        mCurrentOptionsFile.EnableImageDisplay = frmOptions.EnableDisplay;
                        mCurrentOptionsFile.EnableIOAtStartup = frmOptions.EnableIOAtStartup;
                        mCurrentOptionsFile.Write();

                        // handle IO state change
                        if (frmOptions.EnableIO != mJM.IOEnable)
                        {
                            try
                            {
                                mJM.IOEnable = frmOptions.EnableIO;
                            }
                            catch (Cognex.VisionPro.Exceptions.CogException ex)
                            {
                                MessageBox.Show(ResourceUtility.GetString("RtUnexpectedErrorQB") + ex.Message,
                                                mApplicationName);
                            }
                        }
                    }
                    break;
            }
        }

        private void PromptToSaveSettings(string promptString)
        {
            DialogResult result = MessageBox.Show(this, promptString, ResourceUtility.GetString("RtSaveSettingsTitle"),
              MessageBoxButtons.YesNo);
            if (result == DialogResult.Yes)
            {
                if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
                {
                    MessageBox.Show(ResourceUtility.GetString("RtErrorSavingVpp_Running"), mApplicationName);
                    return;
                }

                string vpp = mLoadedVppFilename;
                try
                {
                    bool wasAttached = mAttached;
                    if (wasAttached)
                        AttachToJobManager(false);

                    // save the QuickBuild project file
                    try
                    {
                        Utility.FlushAllQueues(mJM);
                        CogSerializer.SaveObjectToFile(mJM, vpp);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                          mApplicationName);
                    }

                    if (wasAttached)
                        AttachToJobManager(true);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                      mApplicationName);
                }
            }
        }

        private void PromptToSaveSettings_NOMessage(string promptString)
        {

            if (mJM.JobsRunningState != CogJobsRunningStateConstants.None)
            {
                MessageBox.Show(ResourceUtility.GetString("RtErrorSavingVpp_Running"), mApplicationName);
                return;
            }

            string vpp = mLoadedVppFilename;
            try
            {
                bool wasAttached = mAttached;
                if (wasAttached)
                    AttachToJobManager(false);

                // save the QuickBuild project file
                try
                {
                    Utility.FlushAllQueues(mJM);
                    CogSerializer.SaveObjectToFile(mJM, vpp);
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                      mApplicationName);
                }

                if (wasAttached)
                    AttachToJobManager(true);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ResourceUtility.FormatString("RtErrorSavingVpp", vpp) + ex.Message,
                  mApplicationName);
            }
        }


        private void button_SaveSettings_Click(object sender, System.EventArgs e)
        {
            string vpp = mLoadedVppFilename;
            string quotedvpp = "\"" + vpp + "\"";
            string promptStr = ResourceUtility.FormatString("RtSaveSettingsText", quotedvpp);

            PromptToSaveSettings(promptStr);
        }

        private void button_About_Click(object sender, System.EventArgs e)
        {
            // resolve the aboutbox text filename
            string aboutFilename = Utility.ResolveAssociatedFilename(mVppFilename, "about.txt");

            FormAbout about = new FormAbout(aboutFilename, this);
            about.Text = ResourceUtility.FormatString("RtAboutTitle", this.Text);
            about.ShowDialog(this);
        }
        #endregion

        #region GUI update support
        /*
         * The GUI update goals of this application are as follows:
         * 
         * 1.  We would like most, if not all, GUI updates to occur in the context of a
         *     QuickBuild job thread.  This helps to avoid the case where GUI updates
         *     occur in a separate thread, causing job threads to block momentarily at
         *     arbitrary times (for some time critical applications, this behavior is
         *     not acceptable).
         * 
         * 2.  We would like to avoid repainting the GUI every time a new job result is
         *     available, as this rate is application dependent and can occur hundreds of
         *     times per second.  Repainting at a very high rate wastes CPU cycles.
         * 
         * The GUI update strategy of this application is as follows:
         * 
         * 1.  Two flags track the status of GUI updates:
         *     mHaveUnpaintedResults - tracks when new results are available that have
         *       not yet been painted.  This flag is set every time a new user result
         *       is generated by the application.
         *     mMinimumGuiUpdateNeeded - indicates that painting is now required - we've
         *       passed the minimum amount of time between paints and new results are
         *       available.
         * 
         * 2.  A timer (mMinimumGuiPeriodTimer) is set to go off every 50 ms.  If the
         *     handler for this timer determines the we have unpainted results, then it
         *     sets the mMinimumGuiUpdateNeeded flag.
         * 
         * 3.  Every time a new user result is generated, the mMinimumGuiUpdateNeeded
         *     flag is checked (in the "UserResultAvailable" event handler).  If an update
         *     is needed, it is performed immediately, which causes it to occur in the context
         *     of a job thread.
         * 
         * 4.  A second timer (mMaximumGuiPeriodTimer) is set to go off every 500 ms.  This
         *     timer handles the case where user results are generated relatively slowly, or
         *     they stop being generated for some reason (triggers stop occurring, etc).  The
         *     event handler for this timer performs a paint.  In this case, the paint is not
         *     performed in a job thread.
         * 
         * 5.  The mMaximumGuiPeriodTimer is reset every time a paint occurs, such that its
         *     handler is only called if a paint has not happened in the last 500 ms.
         */

        private void mMaximumGuiPeriodTimer_Elapsed(object obj)
        {
            UpdateGui(null, null);
        }

        private void UpdateGui(object sender, System.EventArgs e)
        {
            try
            {
                if (mIsClosing)
                {
                    return;
                }
                if (this.InvokeRequired)
                {
                    // Call this same function on the GUI thread.
                    // Invoke currently has a bug, and it is fixed in .NET2.0
                    IAsyncResult async = BeginInvoke(new System.EventHandler(UpdateGui), new object[] { sender, e });
                    while (!mIsClosing && !async.IsCompleted && !async.AsyncWaitHandle.WaitOne(300, false)) ;

                    // if the VisionControl is closing, updating the GUI is not necessary any more, besides it
                    // might also cause deadlock
                    if (mIsClosing)
                    {
                        async.AsyncWaitHandle.Close();
                    }
                    else
                    {
                        EndInvoke(async);
                    }

                    return;
                }

                // update everything we can on the gui from here

                lock (mMinimumGuiPeriodTimer)
                {
                    mHaveUnpaintedResults = false;
                }

                for (int i = 0; i < mHistoryCollection.Count; ++i)
                {
                    CogJobResultHistoryGated hist = (CogJobResultHistoryGated)mHistoryCollection[i];
                    hist.SnapshotNow();
                }

                UpdateStatisticsForJob(mSelectedJob);
                UpdateOnlineStatus();

                this.Update();

                ResetMaximumGuiUpdateTimer();
                ResetMinimumGuiUpdateTimer();
                lock (mMinimumGuiPeriodTimer)
                {
                    mMinimumGuiUpdateNeeded = false;
                }
            }
            catch { }
        }

        private void ResetMaximumGuiUpdateTimer()
        {
            mMaximumGuiPeriodTimer.Change(MaximumPeriodMs, MaximumPeriodMs);
        }
        private void ResetMinimumGuiUpdateTimer()
        {
            mMinimumGuiPeriodTimer.Change(MinimumPeriodMs, MinimumPeriodMs);
        }

        private void UpdateGuiIfNeeded()
        {
            // this function is called every time a new user result is available.  it performs
            // a paint if the minimum amount of time between paints has elapsed.
            bool updateNeeded;
            lock (mMinimumGuiPeriodTimer)
            {
                updateNeeded = mMinimumGuiUpdateNeeded;
            }

            if (updateNeeded)
                UpdateGui(null, null);
        }

        private void mMinimumGuiPeriodTimer_Elapsed(object obj)
        {
            // the minimum amount of time between paints has elapsed.  if we have any unpainted
            // results, then indicate that the next generated user result should perform a paint.
            bool updateNow = false;

            lock (mMinimumGuiPeriodTimer)
            {
                if (!mMinimumGuiUpdateNeeded && !mHaveUnpaintedResults)
                    ResetMaximumGuiUpdateTimer();
                else
                {
                    updateNow = true;
                    mMinimumGuiUpdateNeeded = true;
                }
            }

            if (updateNow && mCurrentRunState == RunState.Stopped)
                UpdateGui(null, null);
        }

        private void cogJobResultHistory_RequestImmediateUpdate(object sender, System.EventArgs e)
        {
            // called when the user interacts with the scrolling history display (selects a different
            // queue or result record for viewing)
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }
        #endregion

        #region Statistics
        private void ResetStatisticsForAllJobs()
        {
            for (int i = 0; i < mJM.JobCount; i++)
                ResetStatisticsForJob(i);
        }

        private void ResetStatisticsForJob(int i)
        {
            mJM.Job(i).ResetAllStatistics();
            mJM.Job(i).RestartThroughputCalculation();
        }

        private void button_ResetStatisticsForAllJobs_Click(object sender, System.EventArgs e)
        {
            ResetStatisticsForAllJobs();
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }

        private void button_ResetStatistics_Click(object sender, System.EventArgs e)
        {
            ResetStatisticsForJob(mSelectedJob);
            lock (mMinimumGuiPeriodTimer)
            {
                mMinimumGuiUpdateNeeded = true;
            }
        }

        private void UpdateStatisticsForJob(int i)
        {
            // don't update statistics when showing live video
            bool runningLive = mCurrentRunState == RunState.RunningLive;
            if (runningLive)
                return;

            CogJob j = mJM.Job(i);
            textBox_JobN_TotalIterations.Text = j.TotalJobIterations.ToString();
            textBox_JobN_TotalAccept.Text = j.TotalVisionToolAccepts.ToString();
            string percentStr = "";
            if (j.TotalJobIterations > 0)
            {
                double p = j.TotalVisionToolAccepts * 100.0 / j.TotalJobIterations;
                percentStr = p.ToString("0.0");
            }

            textBox_JobN_TotalAccept_Percent.Text = percentStr;
            textBox_JobN_TotalReject.Text = j.TotalVisionToolRejects.ToString();
            textBox_JobN_TotalWarning.Text = j.TotalVisionToolWarnings.ToString();
            textBox_JobN_TotalError.Text = j.TotalVisionToolErrors.ToString();

            textBox_JobN_TotalAcquisitions.Text = j.TotalAcquisitions.ToString();
            textBox_JobN_TotalAcquisitionErrors.Text = j.TotalAcquisitionErrors.ToString();
            textBox_JobN_TotalAcquisitionOverruns.Text = j.TotalAcquisitionOverruns.ToString();

            if (j.TotalJobThroughputMax != 0)
            {
                textBox_JobN_Throughput.Text = j.TotalJobThroughput.ToString("0.000");
                textBox_JobN_MinThroughput.Text = j.TotalJobThroughputMin.ToString("0.000");
                textBox_JobN_MaxThroughput.Text = j.TotalJobThroughputMax.ToString("0.000");
            }
            else
            {
                string waiting = ResourceUtility.GetString("RtStatsWaiting");
                textBox_JobN_Throughput.Text = waiting;
                textBox_JobN_MinThroughput.Text = waiting;
                textBox_JobN_MaxThroughput.Text = waiting;
            }

            #region 获取当前作业组件中的所有非Output的输出值
            CogToolGroup ctg = (CogToolGroup)j.VisionTool;
            List<CogResultsAnalysisTool> list = new List<CogResultsAnalysisTool>();
            //获取当前job中的所有CogResultsAnalysisTool控件
            for (int n = 0; n < ctg.Tools.Count; n++)
            {
                if (ctg.Tools[n] is CogResultsAnalysisTool)
                {
                    list.Add((CogResultsAnalysisTool)ctg.Tools[n]);
                }
            }

            List<CogResults> listData = new List<CogResults>();
            //取出控件中的值并存入Dic
            foreach (CogResultsAnalysisTool cogResults in list)
            {
                if (cogResults.Result == null)
                {
                    break;
                }
                foreach (string key in cogResults.Result.EvaluatedExpressions.Keys)
                {
                    if (key != "Output")
                    {
                        CogResults data = new CogResults();

                        data.cogResultName = cogResults.Name;
                        data.key = key;
                        data.value = cogResults.Result.EvaluatedExpressions[key].Value.ToString();
                        listData.Add(data);
                    }
                }
            }
            this.dataGridView1.DataSource = listData;          



            #endregion
        }
        #endregion

        private void button_Chose_Click(object sender, EventArgs e)
        {
            OpenFileDialog fileDialog = new OpenFileDialog();
            fileDialog.Multiselect = true;
            fileDialog.Title = "请选择文件";
            fileDialog.Filter = "所有文件(*.*)|*.vpp"; //设置要选择的文件的类型
            string file = string.Empty;
            if (fileDialog.ShowDialog() == DialogResult.OK)
            {
                file = fileDialog.FileName;//返回文件的完整路径      
                setApplication(file);

                VisionControl_Load(sender, e);

                string vpp = mLoadedVppFilename;
                string quotedvpp = "\"" + vpp + "\"";
                string promptStr = ResourceUtility.FormatString("RtSaveSettingsText", quotedvpp);
                PromptToSaveSettings_NOMessage(promptStr);
            }
        }
    }


    #region Internal helper classes
    internal class JobData
    {
        public CogJobStartModeConstants lastStartMode = CogJobStartModeConstants.IssuedAfterAcquisitionCompletes;
        public CogJobRunModeConstants lastRunMode = CogJobRunModeConstants.AcquisitionAndImageProcessing;
    }

    // helper class to store localized name and enum value, for use in combo box display
    internal class AccessLevel_Localized
    {
        public AccessLevel_Localized(AccessLevel v, string t)
        {
            val = v;
            text = t;
        }

        public override string ToString()
        {
            // return the localized name
            return text;
        }

        public AccessLevel val;
        public string text;
    }
    #endregion

    #region UserResultAvailable event support
    public class VisionControlUserResultAvailableEventArgs
    {
        public int JobIndex;
        public ICogRecord Result;

        public VisionControlUserResultAvailableEventArgs(int jobIndex, ICogRecord result)
        {
            JobIndex = jobIndex;
            Result = result;
        }
    }

    public delegate void VisionControlUserResultAvailableEventHandler(object sender, VisionControlUserResultAvailableEventArgs e);
    #endregion

    #region defined CogResults
    public class CogResults
    {
        public string cogResultName { get; set; }
        public string key { get; set; }
        public string value { get; set; }
    }
    #endregion
}
